{:title "C# で委譲を行う"
 :tags  ["C#"]
 :layout :post
 :toc true}

C#で委譲を行いたかった。

## 委譲とは？
GoFのデザインパターンに出てくる委譲は、正確には「転送」。  
別クラスに実装を持たせて、呼び出しを別クラスに転送する。  
つまり、元クラスは、切り出した実装の別クラスと同じI/Fを定義しなければならない。  

狭義の委譲とは、元クラスがI/Fを定義しなおすことなく、別クラスの実装のI/Fを元クラスのものとして公開している状態

## 狭義の委譲を実現するにはMixin
Mixinは多重継承を使わないで、クラスの合成ができる。  

## C#でMixinさせる2つの方法
1つは、インターフェースの既定の実装。  
[既定のインターフェイス メソッドを使用して mixin 型を作成する | Microsoft Learn](https://learn.microsoft.com/ja-jp/dotnet/csharp/advanced-topics/interface-implementation/mixins-with-default-interface-methods)  が詳しい。  
Interfaceで関数定義するときに、中身も実装できてしまう。  
ただし、C#8.0以降のサポート。

もう1つは、拡張メソッド。  
拡張メソッドは、既存のクラスに追加の関数を定義できる仕組み。  
staticクラスにstatic関数を定義し、引数に`(this 拡張対象の型 仮引数)`と書く。  
しかし、これは、関数を追加はできるが、Interfaceを実装したことにはならなかったため、狭義の委譲には使えない。

## 結論
インターフェースの既定の実装を使う。  
C#8.0より前なら、あきらめて、委譲したクラスを直接参照させるのが楽か。
